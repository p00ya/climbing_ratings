# Functions for pre-processing ascents data.

# Copyright Contributors to the Climbing Ratings project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


#' Converts ascent labels to all lower-case codes with no spaces.
#'
#' @param ascent_type a label like "Hang dog"
NormalizeAscentType <- function(ascent_type) {
  ascent_type %>%
    stringr::str_to_lower() %>%
    stringr::str_remove_all(stringr::fixed(" ")) %>%
    dplyr::recode(hangdog = "dog")
}

#' Coerces `x[[idx]]` to an integer, replacing NULL with NA.
#'
#' @param x a list/vector of lists
#' @param idx the element of the outer list
.AsIntegerOrNA <- function(x, idx = 1) {
  ifelse(is.null(x), NA, as.integer(x[[idx]]))
}

#' Coerces `x[[idx]]` to a character, replacing NULL with NA.
#' @param x a list/vector of lists
#' @param idx the element of the outer list
.AsCharacterOrNA <- function(x, idx = 1) {
  ifelse(is.null(x), NA, as.character(x[[idx]]))
}

#' Converts the list-of-singleton-integer-list structures typical of jsonlite to
#' an atomic vector of integers.  NULLs are converted to NA.
#'
#' @param lst a list of lists
#' @param idx the element of the outer list
.FlattenInt <- function(lst, idx = 1) {
  purrr::map_int(lst, .AsIntegerOrNA, idx = idx)
}

#' Converts the list-of-singleton-character-list structures typical of jsonlite
#' to an atomic vector of characters.  NULLs are converted to NA.
#'
#' @param lst a list of lists
#' @param idx the element of the outer list
.FlattenChr <- function(lst, idx = 1) {
  purrr::map_chr(lst, .AsCharacterOrNA, idx = idx)
}

#' Reads a CSV export of a climber's logbook from theCrag.
#'
#' @param filename path to file, assumed to be in the format generated by
#' theCrag, i.e. "climber-logbook-YYYY-MM-DD.csv".
#' @return a "raw ascents" data frame with columns "ascentId", "route",
#' "climber", "tick", "grade" and "timestamp".
ReadLogbook <- function(filename) {
  m <- stringr::str_match(
    basename(filename),
    "([^-]+)-logbook-\\d{4}-\\d{2}-\\d{2}"
  )
  climber <- stringr::str_to_lower(m[[1, 2]])
  df <- utils::read.csv(
    filename,
    # R doesn't support 64-bit integers, so force IDs to be interpreted as characters.
    colClasses = c(Ascent.ID = "character", Route.ID = "character"),
    stringsAsFactors = FALSE
  )
  df %>%
    dplyr::select(
      .data$Ascent.ID, .data$Ascent.Type, .data$Route.ID, .data$Route.Grade,
      .data$Ascent.Date
    ) %>%
    dplyr::mutate(
      route = factor(.data$Route.ID),
      climber = .data$climber,
      tick = factor(NormalizeAscentType(.data$Ascent.Type)),
      grade = as.integer(.data$Route.Grade),
      timestamp = .data$Ascent.Date %>%
        as.POSIXct(format = "%FT%H:%M:%SZ", optional = TRUE) %>%
        as.integer()
    ) %>%
    na.omit() %>%
    dplyr::select(
      ascentId = .data$Ascent.ID,
      .data$route,
      .data$climber,
      .data$tick,
      .data$grade,
      .data$timestamp
    )
}

#' Reads all logbooks in a directory.  Logbook filenames are assumed to be
#' in the format generated by theCrag, i.e. "climber-logbook-YYYY-MM-DD.csv".
#'
#' @param dir the directory containing logbook files to read.
#' @return a "raw ascents" data frame with columns "ascentId", "route",
#' "climber", "tick", "grade" and "timestamp".
ReadLogbooks <- function(dir) {
  logbooks <- Sys.glob(file.path(dir, "*-logbook-*.csv"))
  dfs <- purrr::map(logbooks, ReadLogbook)
  dplyr::bind_rows(dfs)
}

#' Downloads ascent data from theCrag's paginated ascent facet API.
#'
#' @param area character node ID on theCrag.
#' @param api_key character API key.
#' @param dir character directory to save JSON responses.
#' @param start integer first page to read.
#' @param per_page integer number of ascents per page.
FetchJsonAscentsFromApi <- function(area, api_key, dir, start = 1L, per_page = 5000L) {
  flatten_param <- paste(
    "data[numberAscents", "page", "perPage", "ascents[id", "route[id]",
    "account[id]", "tick[label]", "gradeID", "gradeScore", "date",
    "pitch[number", "tick[label]]]]",
    sep = ","
  )
  base_url <- paste0(
    "https://sandpit.thecrag.com/api",
    "/facet/ascents/at/", area,
    "/with-route-gear-style/sport",
    "/in-setting/natural",
    "?key=", api_key,
    "&flatten=", flatten_param,
    "&sortby=when",
    "&perPage=", per_page
  )

  for (page in start:1024) {
    url <- paste0(base_url, "&page=", page)
    filename <- file.path(dir, sprintf("ascents-%03d.json", page))

    if (utils::download.file(url, filename, method = "libcurl")) {
      # Stop making requests if there was an error.
      warning(paste("Error downloading URL: ", url))
      break
    }

    j <- jsonlite::read_json(filename)
    names(j) <- "data"
    names(j$data) <- c("numberAscents", "page", "perPage", "ascents")
    # Note the perPage parameter of the request may not be respected; calculate
    # the actual pagination from the response.  The response may code these
    # fields as strings.
    j_num_ascents <- as.integer(j$data$numberAscents)
    j_page <- as.integer(j$data$page)
    j_per_page <- as.integer(j$data$perPage)
    # Stop on the last page.
    if (j_page * j_per_page >= j_num_ascents) {
      break
    }

    # Don't hammer theCrag's servers.
    Sys.sleep(1)
    page <- page + 1
  }
}

#' Parses ascent data from JSON responses as returned by theCrag's ascent facet
#' API.
#'
#' @param json a parsed JSON object as returned by using jsonlite to
#' parse the files written by "FetchJsonAscentsFromApi".
#' @return a "raw ascents" data frame with columns "ascentId", "route",
#' "climber", "tick", "grade" and "timestamp".
ParseJsonAscents <- function(json) {
  names(json) <- "data"
  names(json$data) <- c("numberAscents", "page", "perPage", "ascents")

  # Due to the input JSON's use of heterogeneous arrays, what comes out of
  # jsonlite is horribly structured: ascents is a list, each ascent is a list,
  # and the fields have no names.
  df_json <- as.data.frame(
    do.call(rbind, json$data$ascents),
    stringsAsFactors = FALSE
  )
  # These columns must be consistent with the "flatten"
  colnames(df_json) <-
    c(
      "id", "routeID", "accountID", "tick", "gradeID", "gradeScore",
      "date", "pitch"
    )
  df_json %>%
    dplyr::transmute(
      ascentId = .FlattenChr(.data$id),
      route = .FlattenChr(.data$routeID),
      tick = NormalizeAscentType(.FlattenChr(.data$tick)),
      climber = .FlattenChr(.data$accountID),
      timestamp = .data$date %>%
        .FlattenChr() %>%
        as.POSIXct(format = "%FT%H:%M:%SZ", optional = TRUE) %>%
        as.integer() %>%
        suppressWarnings(),
      grade = .FlattenInt(.data$gradeScore),
      .data$pitch
    ) %>%
    purrr::pmap_dfr(
      function(ascentId, route, tick, climber, timestamp, grade, pitch, ...) {
        if (is.null(pitch)) {
          return(
            data.frame(
              ascentId, tick, grade, climber, timestamp, route,
              stringsAsFactors = FALSE
            )
          )
        }
        # Split an ascent of a multipitch route into multiple ascents
        # corresponding to each pitch.  Suffix the ascent and route IDs, e.g.
        # with a "P2" suffix for pitch 2.
        purrr::map_dfr(pitch, function(p) {
          data.frame(
            pitch.number = .AsIntegerOrNA(p, 1),
            pitch.tick = .AsCharacterOrNA(p, 2),
            stringsAsFactors = FALSE
          )
        }) %>%
          na.omit() %>%
          dplyr::transmute(
            ascentId = paste0(ascentId, "P", .data$pitch.number),
            tick = NormalizeAscentType(unlist(.data$pitch.tick)),
            route = paste0(route, "P", .data$pitch.number),
            grade = grade,
            climber = climber,
            timestamp = timestamp
          )
      }
    )
}

#' Reads all ascent JSON in directory "dir".
#'
#' @param dir character directory containing JSON responses.  JSON filenames
#' are assumed to have the pattern "ascents-*.json".
#' @return a "raw ascents" data frame with columns "ascentId", "route",
#' "climber", "tick", "grade" and "timestamp".
ReadAllJsonAscents <- function(dir) {
  responses <- Sys.glob(file.path(dir, "ascents-*.json"))
  purrr::map(responses, jsonlite::read_json) %>%
    purrr::map(ParseJsonAscents) %>%
    dplyr::bind_rows() %>%
    dplyr::mutate(
      route = factor(.data$route),
      climber = factor(.data$climber),
      tick = factor(.data$tick)
    )
}

#' Classifies tick types into a logical indicating whether the ascent was
#' clean.
#'
#' Note that we have pessimistic interpretations of some tick types that are
#' ambiguous in practice, e.g. a plain "tick" is not counted as clean.
#' Furthermore, no tick shift is applied - a clean top rope ascent is equivalent
#' to an onsight.
#'
#' @param ticktype vector of ticktype codes like "dog".
#' @return a logical vector, which may contain NA values.
IsTickClean <- function(ticktype) {
  # See https://www.thecrag.com/en/article/ticktypes
  dplyr::case_when(
    ticktype %in% c(
      "onsight", "flash", "redpoint", "groundupredpoint",
      "pinkpoint", "clean", "onsightsolo", "topropeonsight", "topropeflash",
      "topropeclean", "secondclean", "leadsolo", "firstfreeascent"
    ) ~ TRUE,
    ticktype %in% c(
      "dog", "attempt", "retreat", "working",
      "allfreewithrest", "toproperest", "ghost", "secondrest"
    ) ~ FALSE
  )
}

#' Tidies a raw ascents table.
#'
#' Removes unclassifiable ascents, removes routes with less than 2 ascents, adds
#' a "clean" column, and re-orders the route levels so the first route has the
#' most ascents at the most common grade.
#'
#' Also prints a summary of the resulting data.
#'
#' @param df_raw data frame with the columns "ascentId", "route", "climber",
#' "tick", "grade", "timestamp".
#' @param min_time a POSIXct; ascents from before this time are removed.
#' @param max_time a POSIXct; ascents from after this time are removed.
CleanAscents <- function(df_raw, min_time = 0L, max_time = NULL) {
  max_time <- ifelse(
    is.null(max_time),
    as.integer(Sys.time()) + 86400L, # + 1 day
    max_time
  )

  df <- df_raw %>%
    dplyr::mutate(clean = IsTickClean(.data$tick)) %>%
    dplyr::filter(!is.na(.data$clean)) %>%
    dplyr::filter(!is.na(.data$grade)) %>%
    dplyr::filter(min_time <= .data$timestamp) %>%
    dplyr::filter(.data$timestamp < max_time)

  # Summarise routes by their grade and number of ascents:
  routes <- df %>%
    dplyr::group_by(.data$route) %>%
    dplyr::summarise(n = dplyr::n(), grade = floor(median(.data$grade)))

  # Make the route with the most ascents for the most common grade the first
  # route.  This means it will be used as the reference route (natural rating
  # prior with mode 0).  Having the most common grade and lots of ascents means
  # it is (hopefully) a good reference point.
  route_grades <- routes %>% dplyr::count(.data$grade)
  routes <- routes %>%
    dplyr::inner_join(
      route_grades,
      by = "grade", suffix = c(".ascents", ".grade")
    ) %>%
    dplyr::arrange(
      dplyr::desc(.data$n.grade),
      dplyr::desc(.data$n.ascents)
    ) %>%
    dplyr::select(-.data$n.grade, -.data$grade)

  # Drop ascents where the route has a single ascent.
  df <- df %>%
    dplyr::inner_join(routes, by = "route") %>%
    dplyr::filter(.data$n.ascents > 1) %>%
    dplyr::select(-.data$n.ascents)

  # Find how often climbers log clean ascents:
  climbers <- df %>%
    dplyr::group_by(.data$climber) %>%
    dplyr::summarise(clean_p = mean(.data$clean))

  # Drop ascents where the climber hasn't logged any non-clean ascents.
  df <- df %>%
    dplyr::inner_join(
      dplyr::filter(climbers, .data$clean_p < 1),
      by = "climber"
    ) %>%
    dplyr::select(-.data$clean_p)

  # Recompute factors from the preprocessed data.
  df <- df %>%
    dplyr::mutate(
      route = .data$route %>%
        droplevels() %>%
        relevel(ref = as.character(routes[[1, 1]])),
      climber = droplevels(.data$climber)
    )

  df
}

#' Summarizes ascents data.
#'
#' @param df a data frame containing ascents (as produced by "CleanAscents").
#' @return a character summary of the ascents.
SummarizeAscents <- function(df) {
  paste(
    prettyNum(nrow(df), big.mark = ","), "ascents by",
    prettyNum(nlevels(df$climber), big.mark = ","), "climbers, over",
    prettyNum(nlevels(df$route), big.mark = ","), "routes;",
    sprintf("%0.2f%%", mean(df$clean) * 100.0), "clean ascents\n"
  )
}

#' Normalizes ascents to ascent, page and route tables.
#'
#' @param df a data frame containing filtered ascents (as produced by
#' "CleanAscents").
#' @param period_length the number of seconds per page.
NormalizeTables <- function(df, period_length) {
  df_routes <- df %>%
    dplyr::group_by(.data$route) %>%
    dplyr::summarise(grade = floor(median(.data$grade)))

  df_ascents <- df %>%
    dplyr::mutate(
      t = (.data$timestamp - min(!!df$timestamp)) %/% period_length,
      clean = as.numeric(.data$clean)
    ) %>%
    dplyr::arrange(.data$climber, .data$t)

  df_pages <- df_ascents %>%
    dplyr::group_by(.data$climber, .data$t) %>%
    dplyr::summarise(timestamp = dplyr::first(.data$timestamp))

  # Set first_page[c] to be the index in df_pages of the first page for climber
  # c.
  first_page <- (
    df_pages %>%
      dplyr::group_by(.data$climber) %>%
      dplyr::summarise(n = dplyr::n()) %>%
      dplyr::mutate(idx = utils::head(cumsum(c(1, .data$n)), -1)))$idx

  df_pages <- df_pages %>%
    dplyr::ungroup() %>%
    dplyr::mutate(page = dplyr::row_number()) %>%
    dplyr::select(.data$climber, .data$t, .data$page, .data$timestamp)

  df_ascents <- df_ascents %>%
    dplyr::inner_join(df_pages, by = c("climber", "t")) %>%
    dplyr::select(.data$route, .data$climber, .data$clean, .data$page)

  list(ascents = df_ascents, pages = df_pages, routes = df_routes)
}

#' Performs a transformation of a grade to a natural rating.
#'
#' This transformation assumes a linear relationship between the grade and the
#' "natural" rating.
#'
#' @param grade numeric vector of grades to transform.
#' @param scale a scale of 1 implies that if a climber has a 0.5 probability of
#' ascending a route at grade X cleanly, then they have a 1 / (1 + e)
#' (approx. 0.27) probability of ascending a route at grade X + 1 cleanly.
#' @param ref the grade to normalize to a natural rating of 0.
TransformGrade <- function(grade, scale = 0, ref = grade[[1]]) {
  scale * (grade - ref)
}

#' Writes normalized tables to CSV files with standard names.
#'
#' @param dfs a list of data frames, with the tags "ascents", "routes" and
#' "pages"; like what NormalizeTables returns.
#' @param dir the directory to write the CSV files to.
WriteNormalizedTables <- function(dfs, dir) {
  utils::write.csv(
    dfs$ascents %>%
      dplyr::mutate(
        route = as.integer(.data$route) - 1,
        page = .data$page - 1
      ) %>%
      dplyr::select(-.data$climber),
    file.path(dir, "ascents.csv"),
    row.names = FALSE
  )
  utils::write.csv(
    dfs$routes %>% dplyr::select(.data$route, .data$rating),
    file.path(dir, "routes.csv"),
    row.names = FALSE
  )
  utils::write.csv(
    dfs$pages %>%
      dplyr::select(.data$climber, timestamp = .data$t) %>%
      dplyr::mutate(climber = as.integer(.data$climber) - 1),
    file.path(dir, "pages.csv"),
    row.names = FALSE
  )
}
